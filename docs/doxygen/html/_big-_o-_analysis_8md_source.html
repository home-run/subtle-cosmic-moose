<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Fantasy Baseball Vacation Documentation: docs/Big-O-Analysis.md Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Fantasy Baseball Vacation Documentation
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">Application for helping a Baseball fan plan out trips in the USA to Baseball Stadiums</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('_big-_o-_analysis_8md.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">docs/Big-O-Analysis.md</div>  </div>
</div><!--header-->
<div class="contents">
<a href="_big-_o-_analysis_8md.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;# Big-O Analysis</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;##Team: ~/run</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;### Group Members</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;* Jesse Mazzella</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;* Sepher Raissaian</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;* Daniel Phan</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;* Dan Karlsson</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;### Algorithms</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;* Dijkstra’s Algorithm</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;* Minimum Spanning Tree - Prims</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;### Data Structures</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;* Graph [Adjacency List – Priority Queue]</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;* Graph [Adjacency Matrix]</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;* Heap [Priority Queue]</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;* VertexSet [Set]</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;* QStack</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;* QVector</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;* QList</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;* QMap</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;## Algorithms</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;### Dijkstra&#39;s Algorithm</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;-----</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;Dijkstra&#39;s Algorithm is used for finding the shortest paths between vertices stored within a graph. The implementation of Dijsktra&#39;s algorithm is a variant of the original and finds the shortest path between a source node and all other nodes within a graph. It uses a minimum-heap priority queue to improve the efficiency of the algorithm when determining the path.</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;__Algorithm__: void Graph::shortestPath(Vertex source)</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;```cpp</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;source = vertexList.at(source.getId());</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;// Initialize all edges, and vertices to infinity</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;initialize_single_source(source);</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;```</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;Function: void Graph::initialize_single_source(Vertex source)</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;This runs in __O(n)__ because `initialize_single_source(source)` will iterate through each vertex in the graph and initialize each vertex with a distance of _INFINITY_ and the parent to _-1_. Then it sets the source vertex to have a distance of 0 to represent it as being the starting vertex.</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;```cpp</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;for(int vertex = 0; vertex &lt; numVertices;vertex++)  // O(n) performance</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;    vertexList[vertex].setDistance(INF);</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;    vertexList[vertex].setParent(-1);</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;vertexList[s.getId()].setDistance(0);</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;```</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;This process is then</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;&gt; __Initialize each vertex in the graph =&gt; O(n)__</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;Then it will initial a vertex set class to be empty and insert the starting vertex into the priority queue of vertices to grab from. This operation is done in __O(1)__ time since the priority queue is empty at this point.</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;```cpp</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;T.clear();</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;vertexPQ.insert(vertexList[source.getId()]);    // O(1) performance</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;```</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;&gt; __Insert into an empty priority queue =&gt; O(1)__</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;Dijkstra&#39;s algorithm will run for as many vertices that there are in the graph what there are __n__ number of vertices. This gives __O(n)__ performance because the algorithm has the check __n__ number of vertices.</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;The removal of a vertex from the priority queue is __O(logn)__ because the removal itself takes __O(1)__ but the _bubble down_ / _min-heapify_ process after the remove of a node from priority queue will take __O(logn)__. </div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;```cpp</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;while(!vertexPQ.isEmpty()){</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;    u = vertexPQ.removeMin();   // O(logn)</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;```</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;&gt;__Removal of a node =&gt; O(1 + logn) ==&gt; O(logn)__ but is only done for each vertex in the graph =&gt; O(n)</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;Next the algorithm will check each vertex to see the adjacent edges have a distance sum of the current vertex plus the weight of the edge is smaller than the distance currently found for the next vertex. Each edge to that vertex is stored within its own priority queue which gives it __O(1)__ access for retrieving the smallest weighted edge to that vertex, but calling `getNearestEdge()` also removes the edge from the priority queue there for producing a __O(logn)__ performance and allowing the next smallest edge being readily accessible.</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;```cpp</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;while(vertexList.at(u.getId()).hasEdges()){</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;    adjEdge = vertexList[u.getId()].getNearestEdge();                               // &lt;= O(logn)</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;    v = vertexList.at(adjEdge.idTo);                                                // &lt;= O(1)</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;    if(adjacencyMatrix[u.getId()][adjEdge.idTo] != 0){</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;        distanceSum = u.getDistance() + adjacencyMatrix[u.getId()][v.getId()];      // &lt;= O(1)</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;        if(v.getDistance() &gt; distanceSum )                                          // &lt;= O(1)</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;            v.setDistance(distanceSum);                                             // &lt;= O(1)</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;            v.setParent(u.getId());                                                 // &lt;= O(1)</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;            vertexList[v.getId()] = v;                                              // &lt;= O(1)</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;        // If the set T of found vertices does not contain the vertex v add the</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;        //  vertex v to the priority queue to see the shorter path.</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;        if(!T.contains(v))          // &lt;= Expected O(1) worst case O(n)</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;            vertexPQ.insert(v);     // &lt;= O(logn)</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;            T.insert(v);            // &lt;= Expected O(1) worst case O(n)</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;```</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;The removal and checking of edges is a O(e) [Edge per node] process since it has to check each adjacent edge for each vertex and each edge has to be checked.</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;Therefore,</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;&gt; Removal and checking of each edge ==&gt; O(e)</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;Since it utilizes a priorty queue to sort the vertices by its current distance it allows the checking off vertices from __O(n)__ to __O(logn)__ for each adjacent vertex.</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;&gt; Checking adjacent vertices for each vertex in the priority queue =&gt; O(nlogn) but since it only needs to check the vertices </div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;&gt; __Initialize each vertices =&gt; O(n) + Insert into priority queue =&gt; O(1) + Removal of a node =&gt; O(n) + Removal and checking of each edge ==&gt; O(e) + Checking adjacent vertices for each vertex =&gt; O(nlogn)__</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;&gt;</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;&gt; __O(n) + O(1) + O(n) + O(e) + O(nlogn)__</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;#### The resulting performance is :</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;&gt; __O(2n + 1 +  e + nlogn) = O(e + nlogn)__</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;### MST prim’s</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;-----</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;The time complexity of Prim&#39;s algorithm depends on the data structures used for the graph and for ordering the edges by weight.Using an adjacency matrix or an adjacency list graph representation and linearly searching an array of weights to find the minimum weight edge, to add requires O(|V|2) running time. However, this running time can be greatly improved further by using heaps to implement finding minimum weight edges in the algorithm&#39;s inner loop. </div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;A first improved version uses a heap to store all edges of the input graph, ordered by their weight. This leads to an O(|E| log |E|) worst-case running time. But storing vertices instead of edges can improve it still further. The heap should order the vertices by the smallest edge-weight that connects them to any vertex in the partially constructed minimum spanning tree (MST) (or infinity if no such edge exists). Every time a vertex v is chosen and added to the MST, a decrease-key operation is performed on all vertices w outside the partial MST such that v is connected to w, setting the key to the minimum of its previous value and the edge cost of (v,w).</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;__Algorithm__: long Graph::minimumSpanningTree(int source)</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;Initialize each vertex in the list, key, and mstSet to INFINITY and not found;</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;```cpp</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;    for(int i = 0; i &lt; numVertices; i++)        // &lt;== O(n)</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;        key[i] = INF;</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;        mstSet[i] = false;</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;        vertexList[i].setParent(-1);</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;        vertexList[i].setDistance(INF);</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;    key[source] = 0;                            // &lt;== O(1)</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;    parent[source] = -1;                        // &lt;== O(1)</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;```</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;&gt; __Initialization takes O(n)__</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;for each vertex in the graph find the minimum weight adjacent edge and set it as discovered</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;```cpp</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;    for(int count = 0; count &lt; numVertices; count++) // &lt;== O(n)</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;        int u = minKey(key, mstSet);</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;        mstSet[u] = true;</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;```</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;__Algorithm__: long Graph::minKey(long key[], bool mstSet[])</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;```cpp</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;    long min = INF;</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;    long min_index;</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;    for(int v = 0; v &lt; numVertices; v++)            // &lt;== O(n)</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;        if(mstSet[v] == false &amp;&amp; key[v] &lt; min)</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;            min = key[v];</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;            min_index = v;</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;    return min_index;</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;```</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;&gt; __Process to find the minimum edge is O(n*n) =&gt; O(n^2)__</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;Checking every edge that is adjacent to the current edge and to see if it has already been visited is a __O(n)__ process.</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;```cpp</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;        for(int v = 0; v &lt; numVertices; v++)         // &lt;== O(n)</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;            if (adjacencyMatrix[u][v] &gt; 0 &amp;&amp; mstSet[v] == false &amp;&amp; adjacencyMatrix[u][v] &lt; key[v])</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;                parent[v] = u;</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;                vertexList[v].setParent(u);</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;                key[v] = adjacencyMatrix[u][v];</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;                vertexList[v].setDistance(key[v]);</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;```</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;&gt; __Process to find the vertex with the smallest possible weight which has not been discovered for each vertex is O(n*n)__</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;&gt; __Since the process takes n + n^2 + n^2__</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;&gt; __O(n + n^2 + n^2) = O(n^2)__</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;### Heap</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;Heap worst case,best case and average case are O(nlogn)</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;The buildMaxHeap() operation is run once, and is O(n) in performance. The bubbleDown() function is O(log(n)), and is called n times. Therefore, the performance of this algorithm is O(n + n * log(n)) which evaluates to O(n log n).</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;Also, the bubbleDown version of heapify has O(n) time complexity, while the bubbleUp version given below has O(n log n) time complexity due to its equivalence with inserting each element, one at a time, into an empty heap.</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;</div></div><!-- fragment --></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="_big-_o-_analysis_8md.html">Big-O-Analysis.md</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
